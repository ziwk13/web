비즈니스 로직 : 컴퓨터 프로그램에서 실제 서비스나 시스템의 핵심적인 역할을 담당하며, 사용자의 요구사항을 처리하고 데이터를 조작하는 규칙과 절차를 의미 한다.
               즉, 프로그램의 핵심적인 기능과 동작 방식을 정의 하는 부분이라고 할 수 있다.
세부 설명 1- 핵심 기능 : 비즈니스 로직은 프로그램이나 서비스의 핵심적인 기능을 구현합니다. 
                        예를 들어, 쇼핑몰 시스템에서는 상품 구매, 결제 처리, 재고 관리 등이 비즈니스 로직에 해당될 수 있습니다
         2- 데이터 처리 : 비즈니스 로직은 데이터를 생성, 표시, 저장, 변경하는 규칙을 정의합니다.
                         사용자의 요청에 따라 데이터를 가공하고 처리하여 원하는 결과를 얻을 수 있도록 합니다
         3- 실세계 규칙 반영 : 비즈니스 로직은 현실 세계의 규칙이나 정책을 프로그램에 반영하는 역할을 합니다. 
                              사용자의 행동, 서비스의 운영 방식 등을 코드에 구현하여 실제 사용 환경과 일치하도록 합니다
         4- 코드 품질 중요 : 비즈니스 로직은 프로그램의 핵심이므로 코드 품질이 매우 중요합니다. 
                            변경이 잦고 복잡해질 수 있으므로, 유지보수와 확장이 용이하도록 설계해야 합니다
         5- 도메인 로직과 유사 : 비즈니스 로직은 종종 도메인 로직과 혼용되기도 합니다. 
                                도메인 로직은 특정 문제 영역의 규칙이나 지식을 코드에 반영하는 것을 의미하며, 넓은 의미에서 비즈니스 로직과 같습니다
         6- 프론트엔드와 백엔드 : 비즈니스 로직은 백엔드에서 주로 처리되지만, 프론트엔드에서도 사용자 인터페이스와 관련된 비즈니스 로직을 구현할 수 있습니다
예시 : 쇼핑몰에서 상품 구매 시, 재고 확인, 결제 처리, 배송 정보 저장 등의 로직이 비즈니스 로직에 해당합니다.
      은행 시스템에서 계좌 이체 시, 잔액 확인, 송금, 수수료 계산 등의 로직이 비즈니스 로직입니다.
      게임에서 레벨업 조건, 아이템 획득 규칙 등의 로직이 비즈니스 로직입니다


Bean : 스프링 컨테이너가 관리하는 자바 객체 스프링 컨테이너는 빈의 생성, 설정, 의존성 관리 등을 담당하며,
       개발자는 이를 통해 객체 간의 관계를 설정하고 재사용 가능한 컴포넌트를 쉽게 만들 수 있다.
주요 특징 1- 스프링 컨테이너 관리 : 스프링 컨테이너는 빈의 생성, 초기화, 소멸 등을 관리 한다
         2- 재사용 가능한 객체 : 빈은 애플리케이션 내에서 여러 곳에서 재사용 될 수 있는 객체
         3-  의존성 주입 : 스프링 컨테이너는 빈 간의 의존성을 관리 하고 주입 해준다.
         4- 다양한 등록 방법: XML 설정, @Bean 어노테이션, @Component, @Service, @Repository 등의 어노테이션을 사용하여 빈을 등록 할 수 있다.

IoC (Inversion of Control) : 제어의 역전 이라고도 하며, IoC를 구현하는 프레임워크로 객체를 관리하고, 객체의 생성을 책임지고, 의존성을 관리하는 컨테이너
                             스프링 애플리케이션에서는 오브젝트(Bean)의 생성과 의존 관계 설정, 사용, 제거 등의 작업을 애플리케이션 코드 대신 스프링 컨테이너가 담당 한다.
                             이를 스프링 컨테이너가 코드 대신 오브젝트에 대한 제어권을 갖고 있다고 해서 IoC라고 부른다.
                             따라서 스프링 컨테이너를 IoC Container라고도 부른다

IoC Container : 스프링에서는 IoC를 담당하는 컨테이너를 빈 팩토리, DI 컨테이너, 애플리케이션 컨텍스트라고 부른다.
                오브젝트의 생성과 오브젝트 사이의 런타임 관계를 설정하는 DI 관점으로 보면, 컨테이너를 빈 팩토리 또는 DI 컨테이너라고 부른다.
                그러나 스프링 컨테이너는 단순한 DI 작업보다 더 많은 일을 하는데, DI를 위한 빈 팩토리에 여러 가지 기능을 추가한 것을 애플리케이션 컨텍스트라고 한다.
                정리하자면, 애플리케이션 컨텍스트는 그 자체로 IoC와 DI 그 이상의 기능을 가졌다고 보면 된다.

Bean Factory : 스프링 컨테이너의 최상위 인터페이스
               스프링 빈을 관리하고 조회하는 역할을 담당
               대표적으로 getBean() 메소드를 제공 한다. 


Annotation : @를 이용하여 자바코드에 추가하여 의미를 부여하는 것으로 프로그램 코드의 일부가 아닌 프로그램에 관한 데이터를 제공 하고,
             코드에 정보를 추가하는 정형화된 방법 (어노테이션을 사용하면 코드가 깔끔해지고 재사용이 가능) 즉, 프로그램에게 추가적인 정보를 제공해주는 메타데이터
             자바에서 사용하는 일반적인 주석의 형태가 아닌 컴파일러가 읽는 주석(JDK 1.5 버전 이상에서 사용 가능)

자주 사용하는 Annotation

 * @Controller
 * 
 * 1. 요청(Request)을 처리하는 컨트롤러 클래스임을 나타내는 어노테이션
 * 2. 클라이언트의 HTTP 요청을 받아 적절한 서비스 메소드를 호출하고, 처리 결과를 뷰(View)로 전달 한다.
 * 3. @Component의 특수화 된 어노테이션으로 Spring Container에 빈으로 자동 등록 된다.
 * 4. 요청 매핑 처리를 위해서 @RequestMapping, @GetMapping, @PostMapping 등의 어노테이션을 함께 사용한다.

 * @Repository
 * 
 * 1. 스프링에서 데이터 접근 계층(DAO, Data Access Object)의 클래스를 나타내는 어노테이션
 * 2. 데이터베이스 등 영속성 저장소와의 CRUD(생성, 조회, 수정, 삭제) 작업을 담당하는 계층임을 명시한다.
 * 3. @Component의 특수화 된 어노테이션으로 Spring Container에 빈으로 자동 등록 된다.
 * 4. 데이터 접근 관련 예외(예: SQLException)는 스프링의 DataAccessException으로 변환하여 일관적인 처리가 가능 하도록 한다.

 * @Service
 * 
 * 1. 비즈니스 로직을 담당하는 클래스임을 명확히 나타내는 어노테이션이다.
 * 2. 컨트롤러(@Controller)와 레파지토리(@Repository) 사이에서 핵심 비즈니스 로직을 구현하는 역할을 한다.
 * 3. @Component의 특수화 된 어노테이션으로 Spring Container에 빈으로 자동 등록 된다.

 * @Autowired
 * 
 * 1. 스프링에서 의존성 주입(Dependency Injection, DI)을 간편하게 처리하기 위해 사용하는 어노테이션
 * 2. Spring Container에 등록된 빈(Bean) 중에서 "타입에 맞는 객체"를 자동으로 찾아서 주입 한다.
 * 3. required 속성 : 디폴트 true. 주입 할 빈(Bean)이 없으면 애플리케이션이 동작하지 않는다. required=false로 설정 하면 예외 없이 실행
 * 4. 타입 기준 검색
 *    1- 우선 타입을 기준으로 해당 빈을 찾는다.
 *    2- 해당 타입의 빈이 1개이면 해당 빈을 주입 한다.
 *    3- 해당 타입의 빈이 2개 이상 이면 예외를 발생 한다.
 *       (1) 필드 이름과 동일한 이름의 빈이 있으면 해당 빈을 주입 한다. (필드 주입)
 *       (2) 파라미터 이름과 동일한 이름의 빈이 있으면 해당 빈을 주입 한다. (수정자, 생성자 주입)
 *       (3) 이름도 일치하는 빈이 없으면 예외가 발생 한다.
 *       (4) 이런 문제를 피하기 위해서 @Qualifier, @Primary를 명시하기도 한다.
 * 5. 스프링에서 인터페이스 타입의 빈을 주입 할 때는 "인터페이스 타입"으로 선언 하는 것이 원칙이며 권장 사항이다.
 * 6. 의존성 주입 대상
 *    1- Field (필드) -> 장점 : 사용하기 편하다
                        단점 : 단일 책임 원칙 위반 가능성이 커진다. @Autowired 선언만 하면 되므로 의존성을 주입하기 쉽다. 따라서, 하나의 클래스가 많은 책임을 갖게 될 가능성이 높다.
                               의존성이 숨는다 -> 생성자 주입에 비해 의존 관계를 한 눈에 파악하기 어렵다.
                               DI 컨테이너와의 결합도가 커지고, 테스트 하기 어렵다
                               불변성을 보장 할 수 없다.
                               순환 참조가 발생 할 수 있다.
 *    2- Setter (수정자) -> 장점 : 빈이 없어도 동작 가능(런타입 오류 발생)  , 선택적인 의존성을 사용 할 수 있다.
                           단점 : 선택적인 의존성을 사용 할 수 있다는 것은 모든 구현체를 주입 하지 않아도 객체를 생성 할 수 있고, 객체의 메소드를 호출 할 수 있다. 즉, 주입받지 않은 구현체를 사용하는 메소드에서 NPE가 발생 한다.
                                  순환 참조 문제가 발생 할 수 있다.
 *    3- Constructor (생성자 : 에 @Autowired 어노테이션을 붙여 의존성을 주입 받을 수 있으며, 가장 권장되는 주입 방식)
                              장점 : 의존 관계를 모두 주입 해야만 객체 생성이 가능 하므로 NPE를 방지 할 수 있다.
                              불변성을 보장 할 수 있다.
                              순환 참조를 컴파일 단계에서 찾아낼 수 있다.
                              의존성을 주입하기 번거롭고, 생성자 인자가 많아지면 코드가 길어져 위기감을 느낄 수 있다.
                              이를 바탕으로 SRP 원칙을 생각하게 되고, 리팩터링을 수행하게 된다.

* @RequestMapping
* 
* 1. 스프링 MVC에서 웹 요청(HTTP 요청)을 특정 컨트롤러 클래스 또는 특정 컨트롤러 메소드에 매핑 할 때 사용하는 어노테이션
* 2. 클라이언트의 요청 주소와 요청 메소드(GET, POST 등)를 컨트롤러의 메소드와 연결하는 역할을 주로 수행 한다.
* 3. 클래스 레벨과 메소드 레벨 모두에서 사용 가능 하다.
*    1- 클래스 레벨 : 공통되는 요청 주소(예: /board/*)지정
*    2- 메소드 레벨 : 세부 요청 주소(예: /board/list, /board/detail 등)를 지정
* 4. 스프링 4.3 부터는 HTTP 메소드별로 간결한 축약 어노테이션을 제공 한다. (예: @GetMapping, @PostMapping 등)
*

* @ModelAttribute - 메소드 파라미터나 메소드 리턴값을 Model 객체에 주입하거나 바인딩 하여 뷰 페이지로 전달하는 역할을 하도록 한다. 메소드 파라미터 또는 메소드 레벨에 사용 될 수 있다.
* Method Argument - 메소드 인자로서 사용한 어노테이션은 Model에서 해당하는 속성을 검색하는 것을 나타낸다. 해당하는 속성이 존재하지 않는 경우 인스턴스화 한 후 Model에 추가 한다. 
*                   파라미터로 지정한 객체의 필드 name이 HTTP 요청 파라미터로 전달된 값의 name과 일치하는 경우 WebDataBinder를 통해 데이터를 자동으로 바인딩 한다.
* Method Level    - 메소드 레벨에 @ModelAttribute 어노테이션을 사용 할 경우 메소드의 목적이 하나 이상의 Model 속성을 추가하는 것임을 나타낸다. 컨트롤러 메소드의 처리가 시작되기 전에 Model 객체가 생성되어야 하기 때문에, 

RedirectAttributes - 리디렉션을 수행 할 때 한 컨트롤러 메소드에서 다른 컨트롤러 메소드로 Attributes를 전달 하는데 이용되는 스프링 프레임워크의 인터페이스
                     일반적인 시나리오에서 Attributes를 저장 할 땐 Model의 addAttribute() 메소드를 많이 이용 한다.
                     예: 주문이 완료 된 후 주문 결과 상세페이지로 리다이렉팅 하고 그 결과를 보여주고 싶을 때 이용 할 수 있다.
                         주문 처리가 끝났을 때 생성된 주문번호를 리다이렉트 페이지쪽으로 넘겨줄 수 있다.
RedirectAttributes로 넘긴 데이터 접근하기
- addAttribute()로 넘겼다면 URL로 넘어온 만큼 기존처럼 @RequestParam 어노테이션을 이용
- addFlashAttributes()로 넘겼다면, @ModelAttribute 어노테이션을 이용 또는 Model 오브젝트를 파라미터에서 이용하고, model.getAttribute()를 사용 해도 된다.


addAttribute() - 브라우저의 주소창에 보이게 URL에 추가하여 정보를 넘긴다
                 주소창에 보이는 만큼 짧은 정보, 이용자에게 노출되어도 상관 없는 정보를 넘기는데에 주로 사용한다.
                 쿼리 파라미터가 있는 URL에 접근하는 한 여러 요청에 사용이 가능 하다.
                 /targetURL?key=value 형직으로 전달 된다.

addFlashAttributes() - 세션에 저장되고 오직 다음 요청에만 접근 가능 하다.
                       1- 임시로 저장 하는 방식이다
                       2- 세션에 저장되어 사용된 뒤에 자동으로 삭제된다
                       3- 검증 결과, 성공 실패 여부 메시지와 같이 임시로 사용되는 데이터를 다루는데 적합하다.
                       4- 주소 창에 표기 되지 않으므로 addAttribute() 보다 폐쇄적이다.

Redirect - 클라이언트가 서버에 특정 URL로 요청을 보내면, 서버는 클라이언트에게 다른 URL로 다시 요청 하라고 응답 한다.
           클라이언트는 새로운 URL로 다시 요청을 보내야 하므로 주소 표시줄의 URL이 변경 된다.
           특징 : 1 - 클라이언트가 두 번 요청 하게 된다.
                  2 - 주소 표시줄의 URL이 변경 된다
                  3 - 서버 부담이 조금 더 클 수 있다.

Forward - 클라이언트의 요청을 서버 내부에서 다른 페이지로 전달 한다.
          클라이언트는 서버가 다른 페이지로 이동 했다는 사실을 알지 못 한다.
          주소 표시줄의 URL은 처음 요청한 URL 그대로 유지 된다.
          특징: 1 - 클라이언트는 한 번만 요청 한다.
                2 - 주소 표시줄의 URL이 변경되지 않는다.
                3 - 서버 부담이 적다

*** 시스템(session, DB)에 변화가 생기는 요청(로그인, 회원가입, 글쓰기)의 경우 redirect방식으로 응답하는 것이 바람직 하며, 시스템에 변화가 생기지 않는 단순조회(리스트보기, 검색)의 경우 forward 방식으로 응답하는것이 좋다. *** 

                                                                                    ----- 트랜잭션(Transaction)과 ACID -----
                                                            데이터 베이스 트랜잭션은 단일 작업 단위로 실행되는 하나 이상의 데이터베이스 작업 시퀸스 라고 한다.
                                                                        트랜잭션은 ACID 원칙을 적용하여 데이터 일관성과 무결성을 보장한다.
                                                                              ACID는 원자성, 일관성, 격리성, 내구성을 의미 한다

원자성(Atomicity) : 트랜잭션은 원자적이어서 분할 할 수 없는 단일 작업 단위로 취급 된다.
                   트랜잭션의 모든 작업이 완료 되거나 완료되지 않을 수 있다
                   트랜잭션이 어느 시점에서든 실패하면 데이터베이스에 적용된 모든 변경 사항이 롤백 되고 데이터베이스는 원래 상태로 돌아간다
일관성(Consistency) : 트랜잭션은 트랜잭션 전후에 데이터베이스가 일관성을 유지해야 한다.
                     즉, 데이터베이스는 트랜잭션이 실행되기 전과 후에 모두 유효한 상태여야 한다.
                     트랜잭션이 기본 키 또는 외래 키 제약 조건과 같은 데이터베이스 제약 조건을 위반하는 경우 트랜잭션은 롤백 된다.
격리성(Isolation) : 트랜잭션은 서로 간섭 할 수 ㅇ벗도록 서로 격리되어야 한다. 다중 사용자 환경에서는 트랜잭션이 동시에 실행되므로 각 트랜잭션이 격리되어 다른 트랜잭션의 결과에 영향을 미치지 않도록 하는것이 중요 하다.
영속성(Durability) : 트랜잭션이 커밋되면 데이터베이스에 대한 변경 내용이 영구적으로 유지되어야 하며 시스템 충돌이나 정전과 같은 후속 장애애도 영향을 받지 않아야 한다.

@Transaction Annotation : 데이터베이스 작업에서 트랜잭션을 관리하는데서 사용되는 어노테이션. 트랜잭션을 관리하는 선언적 방법을 제공하며 트랜잭션 어노테이션은 클래스 또는 메소드 레벨에 적용 할 수 있다.
                          클래스 수준에서 적용 : 클래스의 모든 메소드에 대한 기본 트랜잭션 설정을 설정 한다.
                          메소드 수준에서 적용 : 해당 특정 메소드의 class-level settiongs 값을 overrides 한다.
특징 : 1. 트랜잭션의 전파 유형(Transaction Propagation Types) - 트랜잭션 어노테이션의 propagation attribute를 사용하여 트랜잭션 전파 유형을 지정할 수도 있다.
                                                            propagation type는 여러 트랜잭션이 관련된 경우 트랜잭션이 전파되는 방식을 결정 한다.
                              (1) Required      : 기본 전파 유형
                                                  트랜잭션이 이미 있는 경우 현재 메소드가 해당 트랜잭션에 참여 한다.
                                                  트랜잭션이 존재하지 않으면 메소드에 대한 새 트랜잭션이 생성 된다. (REQUIRED는 Default 이므로 생략 가능)
                              (2) Requires New  : 이 전파 유형은 항상 새 트랜잭션을 만든다.
                                                 트랜잭션이 이미 존재하는 경우 새 트랜잭션이 완료될 때 까지 일시 중단 한다.
                              (3) Nested        : 이 전파 유형은 중첩된 트랜잭션을 생성함.
                                                  트랜잭션이 이미 존재하는 경우 새 트랜잭션이 생성되어 기존 트랜잭션 내에 중첩됨.
                                                  트랜잭션이 존재 하지 않으면 새 트랜잭션이 생성됨
                              (4) Supports      : 이 전파 유형은 트랜잭션이 이미 존재하는 경우 트랜잭션을 지원
                                                  트랜잭션이 존재하면 해당 트랜잭션 내에서 현재 메소드가 실행
                                                  트랜잭션이 존재하지 않으면 트랜잭션 없이 메소드가 실행
                              (5) Mandatory     : 이 전파 유형은 트랜잭션이 이미 존재해야 한다.
                                                  트랜잭션이 존재하지 않으면 예외가 발생 한다.
                              (6) Not Supported : 이 전파 유형은 트랜잭션을 지원하지 않음
                                                  트랜잭션이 존재하면 현재 메소드가 실행되는 동안 트랜잭션이 일시 중단됨.
                              (7) Never         : 이 전파 유형은 현재 메소드가 실행될 때 트랜잭션이 존재하지 않은지 확인 한다.
                                                  트랜잭션이 존재하면 예외가 발생 한다.
      2. 동시성 부작용(concurrency side effects)과 트랜잭션의 격리 수준(Isolation Levels) - 트랜잭션 격리 수준(Transaction Iolation Levels)은 concurrent 트랜잭션에 의해 적용된 변경 사항이 서로에게 표시되는 방식을 설명 한다.
                                                                                       concurrent 트랜잭션 : 여러 사용자가 동시에 실행할 수 있는 트랜잭션
                                                                                       격리 수준은 트랜잭션에서 0개 이상의 동시성 부작용(concurrency side effects)을 방지 한다
            (1) Dirty read : concurrent 트랜잭션의 커밋되지 않은 변경 내용을 읽는다
            (2) Norepeatable read : concurrent 트랜잭션이 동일한 행을 업데이트 하고 커미샇는 경우 행을 다시 읽을 때 다른 값을 가져온다
            (3) Phantom read : 다른 트랜잭션이 범위의 일부 행을 추가 또는 제거 하고 커밋하는 경우 range-query를 다시 실행한 후 다른 행을 가져온다.
      3. 트랜잭션에 의해 래핑 된 연산에 대한 시간제한
      4. readOnly flag : 트랜잭션이 readOnly여야 한다는 persistence provider에게 hint 제공
      5. 트랜잭션에 대한 롤백 규칙 : 기본적으로 롤백은 런타임에 unchecked exceptions에 대해서만 발생. checked exception는 트랜잭션의 롤백을 트리거하지 않음.